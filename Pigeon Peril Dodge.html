<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pigeon Peril Dodge - Made with Ludo.ai</title>
    <meta name="description" content="Interactive playable game created with Ludo.ai - AI-powered game development platform">
    <meta name="generator" content="Ludo.ai">
    <meta name="author" content="Ludo.ai">
    <meta name="keywords" content="playable game, interactive, AI-generated, Ludo.ai, pixijs">
    <meta name="created-date" content="2025-11-27">
    <meta name="game-engine" content="pixijs">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŽ®</text></svg>">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .game-header {
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            flex-shrink: 0;
        }
        .game-title {
            font-size: 18px;
            font-weight: 600;
            margin: 0 0 4px 0;
            color: #fff;
        }
        .game-info {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin: 0;
        }
        .game-description {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.9);
            margin: 8px 0 0 0;
            line-height: 1.4;
        }
        .game-engine {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin-left: 8px;
            text-transform: uppercase;
            font-weight: 500;
        }
        #gameContainer {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 0;
        }
        canvas {
            display: block;
            margin: 0 auto;
            max-width: 100vw;
            max-height: 100vh;
            width: auto;
            height: auto;
        }
        body > canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        .ludo-footer {
            position: fixed;
            bottom: 0;
            right: 0;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.7);
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
            text-decoration: none;
            border-top-left-radius: 4px;
            transition: all 0.2s ease;
            z-index: 1000;
        }
        .ludo-footer:hover {
            background: rgba(0, 0, 0, 0.9);
            color: rgba(255, 255, 255, 0.9);
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1 class="game-title">Pigeon Peril Dodge</h1>
        <p class="game-info">
            Created with Ludo.ai on 2025-11-27
            <span class="game-engine">pixijs</span>
        </p>
        <p class="game-description">A 2D action game where players control an elderly woman dodging pigeon attacks and retaliating in a city park. Build combos to unleash attacks and defeat the boss pigeon king.</p>
        <p class="game-description"><strong>How to Play:</strong> Use the Left and Right arrow keys to dodge incoming projectiles. Fill the combo meter by successfully dodging to enter the attack phase. In the attack phase, press the Spacebar to attack the boss. Survive the onslaught to achieve victory.</p>
    </div>
    <div id="gameContainer"></div>
    <a href="https://ludo.ai" target="_blank" class="ludo-footer">
        Made with Ludo.ai
    </a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.3/pixi.min.js" integrity="sha512-o3fAFcbCbTTJRFRNx4vByRZVtdKYF9uklctNjDXrN1JjT00rJxCCyNJSDi35rPBEqzWvYplcHLlEmyW34Ado8A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><script src="https://cdn.jsdelivr.net/npm/pixi-filters@5.3.0/dist/browser/pixi-filters.min.js"></script>
    <script type="module">
        // Ludo.ai Playable Game
        // Generated on: 2025-11-27
        // Engine: pixijs
        // Title: Pigeon Peril Dodge
        
        // Monitor for canvas elements and move them to gameContainer
        const gameContainer = document.getElementById('gameContainer');
        
        // Function to move canvas elements to gameContainer
        function moveCanvasToContainer() {
            const canvases = document.querySelectorAll('body > canvas');
            canvases.forEach(canvas => {
                if (canvas.parentElement === document.body) {
                    gameContainer.appendChild(canvas);
                }
            });
        }
        
        // Monitor for new canvas elements
        const observer = new MutationObserver(() => {
            moveCanvasToContainer();
        });
        observer.observe(document.body, { childList: true });
        
        // Initial check
        setTimeout(moveCanvasToContainer, 100);
        
        // ===== RUNTIME LIBRARY =====
// PixiJS Runtime Library
// This library provides utility functions for PixiJS games
// All functions are side-effect free and only execute when called

// ===== ASSET MANAGEMENT =====

const __FALLBACK_ASSET__ = {
  url: "https://storage.googleapis.com/scraper_ludo/user_images_dev/45f550b2dafbaa5d6f59a0af127d9fa2.png",
  width: 200,
  height: 200,
  description: "Fallback asset (placeholder)"
};

// getAssetUrl(key) -> string
function getAssetUrl(key) {
  const asset = __ASSET_MAP__[key];
  if (!asset) {
    console.warn(`Asset '${key}' not found in asset map, using fallback asset`);
    return __FALLBACK_ASSET__.url;
  }
  return asset.url;
}

// getAssetInfo(key) -> {url, width, height, description}
function getAssetInfo(key) {
  const asset = __ASSET_MAP__[key];
  if (!asset) {
    console.warn(`Asset '${key}' not found in asset map, using fallback asset`);
    return __FALLBACK_ASSET__;
  }
  return {
    url: asset.url,
    width: asset.width,
    height: asset.height,
    description: asset.description
  };
}

// createSprite(key, {x, y, scale, width, height, anchor}) -> Sprite
// Use width OR height (not both) to maintain aspect ratio. anchor can be number or {x, y}
function createSprite(key, options = {}) {
  const assetInfo = getAssetInfo(key);
  const sprite = PIXI.Sprite.from(assetInfo.url);

  // Initialize userData to store base scale
  sprite.userData = sprite.userData || {};

  if (options.scale !== undefined) {
    sprite.scale.set(options.scale);
    sprite.userData.baseScale = options.scale;
  }

  if (options.x !== undefined) sprite.x = options.x;
  if (options.y !== undefined) sprite.y = options.y;

  if (options.anchor !== undefined) {
    if (typeof options.anchor === 'number') {
      sprite.anchor.set(options.anchor);
    } else if (options.anchor.x !== undefined || options.anchor.y !== undefined) {
      sprite.anchor.set(options.anchor.x || 0, options.anchor.y || 0);
    }
  }

  if (options.width !== undefined) {
    const aspectRatio = assetInfo.width / assetInfo.height;
    sprite.width = options.width;
    sprite.height = options.width / aspectRatio;
    sprite.userData.baseScale = sprite.scale.x;
    sprite.userData.targetWidth = options.width;
  } else if (options.height !== undefined) {
    const aspectRatio = assetInfo.width / assetInfo.height;
    sprite.height = options.height;
    sprite.width = options.height * aspectRatio;
    sprite.userData.baseScale = sprite.scale.x;
    sprite.userData.targetHeight = options.height;
  }

  // If no scale was set, store the default
  if (sprite.userData.baseScale === undefined) {
    sprite.userData.baseScale = 1;
  }

  // Override scale.set to work relatively to baseScale
  const originalScaleSet = sprite.scale.set.bind(sprite.scale);

  sprite.scale.set = function(x, y) {
    // Read baseScale dynamically from userData to avoid race conditions
    let baseScale = sprite.userData?.baseScale || 1;

    // Safety check: if texture loaded after baseScale was calculated, recalculate
    if (sprite.userData.targetWidth && sprite.texture && sprite.texture.valid) {
      const expectedScale = sprite.userData.targetWidth / sprite.texture.width;
      // If current baseScale is way off (close to 1 when it should be small), recalculate
      if (Math.abs(baseScale - expectedScale) > 0.01 && Math.abs(baseScale - 1.0) < 0.01) {
        baseScale = expectedScale;
        sprite.userData.baseScale = expectedScale;
      }
    }

    if (y === undefined) {
      // single value: scale.set(1.2)
      return originalScaleSet(x * baseScale, x * baseScale);
    } else {
      // two values: scale.set(1.2, 1.5)
      return originalScaleSet(x * baseScale, y * baseScale);
    }
  };

  // Keep original for absolute scaling if needed
  sprite.scale.setAbsolute = originalScaleSet;

  return sprite;
}

// createContainedSprite(key, containerWidth, containerHeight, options) -> Sprite
// options: {fitMode, align, anchor}
// fitMode: 'contain' (fit inside, default), 'cover' (fill, may crop), 'fill' (stretch)
// align: 'center' (default), 'top', 'bottom', 'left', 'right', 'top-left', etc.
function createContainedSprite(key, containerWidth, containerHeight, options = {}) {
  const assetInfo = getAssetInfo(key);
  const sprite = PIXI.Sprite.from(assetInfo.url);

  // Store container dimensions
  sprite.userData = sprite.userData || {};
  sprite.userData.containerWidth = containerWidth;
  sprite.userData.containerHeight = containerHeight;

  // Calculate scale based on fit mode
  const fitMode = options.fitMode || 'contain';
  let scale;

  if (fitMode === 'fill') {
    // Stretch to fill container
    sprite.scale.set(
      containerWidth / assetInfo.width,
      containerHeight / assetInfo.height
    );
  } else if (fitMode === 'cover') {
    // Scale to cover container (may crop)
    scale = Math.max(
      containerWidth / assetInfo.width,
      containerHeight / assetInfo.height
    );
    sprite.scale.set(scale);
  } else {
    // Contain - fit inside container
    scale = Math.min(
      containerWidth / assetInfo.width,
      containerHeight / assetInfo.height
    );
    sprite.scale.set(scale);
  }

  sprite.userData.baseScale = sprite.scale.x;

  // Set alignment/anchor
  const align = options.align || 'center';

  if (options.anchor !== undefined) {
    // Custom anchor provided
    if (typeof options.anchor === 'number') {
      sprite.anchor.set(options.anchor);
    } else {
      sprite.anchor.set(options.anchor.x || 0, options.anchor.y || 0);
    }
  } else {
    // Set anchor based on alignment
    switch (align) {
      case 'center':
        sprite.anchor.set(0.5, 0.5);
        sprite.x = containerWidth / 2;
        sprite.y = containerHeight / 2;
        break;
      case 'top-left':
        sprite.anchor.set(0, 0);
        break;
      case 'top':
        sprite.anchor.set(0.5, 0);
        sprite.x = containerWidth / 2;
        break;
      case 'top-right':
        sprite.anchor.set(1, 0);
        sprite.x = containerWidth;
        break;
      case 'left':
        sprite.anchor.set(0, 0.5);
        sprite.y = containerHeight / 2;
        break;
      case 'right':
        sprite.anchor.set(1, 0.5);
        sprite.x = containerWidth;
        sprite.y = containerHeight / 2;
        break;
      case 'bottom-left':
        sprite.anchor.set(0, 1);
        sprite.y = containerHeight;
        break;
      case 'bottom':
        sprite.anchor.set(0.5, 1);
        sprite.x = containerWidth / 2;
        sprite.y = containerHeight;
        break;
      case 'bottom-right':
        sprite.anchor.set(1, 1);
        sprite.x = containerWidth;
        sprite.y = containerHeight;
        break;
    }
  }

  // Override scale.set to work relatively to baseScale
  const originalScaleSet = sprite.scale.set.bind(sprite.scale);

  sprite.scale.set = function(x, y) {
    // Read baseScale dynamically from userData to avoid race conditions
    const baseScale = sprite.userData?.baseScale || 1;
    if (y === undefined) {
      return originalScaleSet(x * baseScale, x * baseScale);
    } else {
      return originalScaleSet(x * baseScale, y * baseScale);
    }
  };

  sprite.scale.setAbsolute = originalScaleSet;

  return sprite;
}

// createTilingSprite(key, width, height, {x, y, tileScale}) -> TilingSprite
// Tiles the texture to fill width x height while maintaining aspect ratio
function createTilingSprite(key, width, height, options = {}) {
  const assetInfo = getAssetInfo(key);
  const tilingSprite = new PIXI.TilingSprite(
    PIXI.Texture.from(assetInfo.url),
    width,
    height
  );

  if (options.x !== undefined) tilingSprite.x = options.x;
  if (options.y !== undefined) tilingSprite.y = options.y;

  // Calculate scale to match target height while maintaining aspect ratio
  const scaleToFitHeight = height / assetInfo.height;

  if (options.tileScale !== undefined) {
    tilingSprite.tileScale.set(options.tileScale);
  } else {
    // Auto-scale to fill height, tiles will repeat horizontally
    tilingSprite.tileScale.set(scaleToFitHeight);
  }

  return tilingSprite;
}

// preloadAssets(assetMap, onProgress, onComplete) -> Promise
// onProgress(loaded, total, percent) and onComplete() callbacks
async function preloadAssets(assetMap, onProgress, onComplete) {
  const urls = Object.values(assetMap).map(asset => asset.url);
  const uniqueUrls = [...new Set(urls)];

  let loaded = 0;
  const total = uniqueUrls.length;

  try {
    await Promise.all(
      uniqueUrls.map(async (url) => {
        await PIXI.Assets.load(url);
        loaded++;
        if (onProgress) {
          onProgress(loaded, total, loaded / total);
        }
      })
    );

    if (onComplete) {
      onComplete();
    }
  } catch (error) {
    console.error('Error preloading assets:', error);
  }
}

// ===== SPRITE SCALING HELPERS =====

/**
 * Resets sprite to its original base scale (1.0 relative)
 * @param {PIXI.Sprite} sprite - The sprite to reset
 */
function resetSpriteScale(sprite) {
  sprite.scale.set(1);
}

/**
 * Animates a sprite with a pulse effect
 * @param {PIXI.Sprite} sprite - The sprite to pulse
 * @param {number} [intensity=0.1] - Pulse intensity (0.1 = 10% larger)
 * @param {number} [duration=150] - Duration in milliseconds
 */
function pulseSpriteScale(sprite, intensity = 0.1, duration = 150) {
  const pulseScale = 1 + intensity;
  sprite.scale.set(pulseScale);

  setTimeout(() => {
    sprite.scale.set(1);
  }, duration);
}

/**
 * Animates sprite scale change smoothly
 * @param {PIXI.Sprite} sprite - The sprite to animate
 * @param {number} targetMultiplier - Target scale multiplier
 * @param {number} [speed=0.2] - Animation speed (0-1, higher = faster)
 * @param {Function} [onComplete] - Callback when animation completes
 */
function animateSpriteScale(sprite, targetMultiplier, speed = 0.2, onComplete) {
  const baseScale = sprite.userData?.baseScale || 1;
  const targetScale = baseScale * targetMultiplier;
  const currentAbsolute = sprite.scale.x;

  const animate = () => {
    const newAbsolute = lerp(currentAbsolute, targetScale, speed);
    sprite.scale.setAbsolute(newAbsolute);

    if (Math.abs(newAbsolute - targetScale) > 0.01) {
      requestAnimationFrame(animate);
    } else {
      sprite.scale.setAbsolute(targetScale);
      if (onComplete) onComplete();
    }
  };

  animate();
}

// ===== COLLISION DETECTION =====

// rectangleCollision(rect1, rect2) -> boolean
// rect: {x, y, width, height}
function rectangleCollision(rect1, rect2) {
  return (
    rect1.x < rect2.x + rect2.width &&
    rect1.x + rect1.width > rect2.x &&
    rect1.y < rect2.y + rect2.height &&
    rect1.y + rect1.height > rect2.y
  );
}

// spriteCollision(sprite1, sprite2) -> boolean
function spriteCollision(sprite1, sprite2) {
  const bounds1 = sprite1.getBounds();
  const bounds2 = sprite2.getBounds();

  return rectangleCollision(
    { x: bounds1.x, y: bounds1.y, width: bounds1.width, height: bounds1.height },
    { x: bounds2.x, y: bounds2.y, width: bounds2.width, height: bounds2.height }
  );
}

// circleCollision(obj1, obj2) -> boolean
// Auto-detects radius from obj.radius or obj.width/2
function circleCollision(obj1, obj2) {
  const dx = obj1.x - obj2.x;
  const dy = obj1.y - obj2.y;
  const distance = Math.sqrt(dx * dx + dy * dy);

  const radius1 = obj1.radius || obj1.width / 2 || 0;
  const radius2 = obj2.radius || obj2.width / 2 || 0;

  return distance < radius1 + radius2;
}

// ===== BOUNDARY HELPERS =====

// setupBoundaryCollision(sprite, bounds) -> 'left'|'right'|'top'|'bottom'|null
// bounds: {left, right, top, bottom}
function setupBoundaryCollision(sprite, bounds) {
  if (sprite.x < bounds.left) {
    sprite.x = bounds.left;
    return 'left';
  }
  if (sprite.x + sprite.width > bounds.right) {
    sprite.x = bounds.right - sprite.width;
    return 'right';
  }
  if (sprite.y < bounds.top) {
    sprite.y = bounds.top;
    return 'top';
  }
  if (sprite.y + sprite.height > bounds.bottom) {
    sprite.y = bounds.bottom - sprite.height;
    return 'bottom';
  }
  return null;
}

// wrapAroundScreen(sprite, app) -> void
function wrapAroundScreen(sprite, app) {
  if (sprite.x > app.screen.width) {
    sprite.x = -sprite.width;
  } else if (sprite.x + sprite.width < 0) {
    sprite.x = app.screen.width;
  }

  if (sprite.y > app.screen.height) {
    sprite.y = -sprite.height;
  } else if (sprite.y + sprite.height < 0) {
    sprite.y = app.screen.height;
  }
}

// keepOnScreen(sprite, app) -> void
function keepOnScreen(sprite, app) {
  if (sprite.x < 0) sprite.x = 0;
  if (sprite.y < 0) sprite.y = 0;
  if (sprite.x + sprite.width > app.screen.width) {
    sprite.x = app.screen.width - sprite.width;
  }
  if (sprite.y + sprite.height > app.screen.height) {
    sprite.y = app.screen.height - sprite.height;
  }
}

// ===== PHYSICS HELPERS =====

// applyVelocity(sprite, velocity, delta) -> void
// Initializes sprite.velocity if needed
function applyVelocity(sprite, velocity, delta = 1) {
  if (!sprite.velocity) {
    sprite.velocity = { ...velocity };
  }

  sprite.x += sprite.velocity.x * delta;
  sprite.y += sprite.velocity.y * delta;
}

// ===== UI HELPERS =====

// createText(text, style, position) -> Text
// style: {fontSize, fill, ...}, position: {x, y, anchor}
function createText(text, style = {}, position = {}) {
  const defaultStyle = {
    fontSize: 24,
    fill: 0xffffff,
    ...style
  };

  const textObject = new PIXI.Text(text, defaultStyle);

  if (position.x !== undefined) textObject.x = position.x;
  if (position.y !== undefined) textObject.y = position.y;

  if (position.anchor !== undefined) {
    if (typeof position.anchor === 'number') {
      textObject.anchor.set(position.anchor);
    } else if (position.anchor.x !== undefined || position.anchor.y !== undefined) {
      textObject.anchor.set(position.anchor.x || 0, position.anchor.y || 0);
    }
  }

  return textObject;
}

// centerObject(object, app) -> void
function centerObject(object, app) {
  object.x = (app.screen.width - object.width) / 2;
  object.y = (app.screen.height - object.height) / 2;
}

// createButton(text, position, onClick, style) -> Text
// position: {x, y, anchor}, style: {fontSize, fill, hoverColor}
function createButton(text, position, onClick, style = {}) {
  const defaultStyle = {
    fontSize: 24,
    fill: 0xffffff,
    ...style
  };

  const button = new PIXI.Text(text, defaultStyle);
  button.x = position.x;
  button.y = position.y;

  if (position.anchor !== undefined) {
    if (typeof position.anchor === 'number') {
      button.anchor.set(position.anchor);
    } else if (position.anchor.x !== undefined || position.anchor.y !== undefined) {
      button.anchor.set(position.anchor.x || 0, position.anchor.y || 0);
    }
  } else {
    button.anchor.set(0.5);
  }

  button.eventMode = 'static';
  button.cursor = 'pointer';

  button.on('pointerdown', onClick);

  button.on('pointerover', () => {
    button.style.fill = style.hoverColor || 0xffff00;
  });

  button.on('pointerout', () => {
    button.style.fill = style.fill || 0xffffff;
  });

  return button;
}

// createRestartButton(app, position, onRestart) -> Text
function createRestartButton(app, position = {}, onRestart) {
  const x = position.x !== undefined ? position.x : app.screen.width / 2;
  const y = position.y !== undefined ? position.y : app.screen.height / 2 + 60;

  return createButton('Restart', { x, y, anchor: 0.5 }, onRestart, {
    fontSize: 32,
    fill: 0xffffff
  });
}

// showGameOver(app, {title, score, onRestart}) -> Container
function showGameOver(app, options = {}) {
  const container = new PIXI.Container();

  const background = new PIXI.Graphics();
  background.beginFill(0x000000, 0.7);
  background.drawRect(0, 0, app.screen.width, app.screen.height);
  background.endFill();
  container.addChild(background);

  const gameOverText = createText(
    options.title || 'Game Over',
    { fontSize: 48, fill: 0xff0000 },
    { x: app.screen.width / 2, y: app.screen.height / 2 - 50, anchor: 0.5 }
  );
  container.addChild(gameOverText);

  if (options.score !== undefined) {
    const scoreText = createText(
      `Score: ${options.score}`,
      { fontSize: 32, fill: 0xffffff },
      { x: app.screen.width / 2, y: app.screen.height / 2, anchor: 0.5 }
    );
    container.addChild(scoreText);
  }

  if (options.onRestart) {
    const restartButton = createRestartButton(app, {}, options.onRestart);
    container.addChild(restartButton);
  }

  return container;
}

// ===== KEYBOARD INPUT =====

const __keyboard = {
  keys: {},
  _initialized: false
};

(function initKeyboard() {
  if (__keyboard._initialized) return;

  window.addEventListener('keydown', (e) => {
    __keyboard.keys[e.key] = true;
  });

  window.addEventListener('keyup', (e) => {
    __keyboard.keys[e.key] = false;
  });

  __keyboard._initialized = true;
})();

// isKeyDown(key) -> boolean
// Check if a key is currently pressed
// Common keys: 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' ' (space), 'w', 'a', 's', 'd'
function isKeyDown(key) {
  return __keyboard.keys[key] || false;
}

// ===== DRAG AND DROP =====

// makeDraggable(sprite, {dragLayer, onDragStart, onDrag, onDragEnd}) -> void
// IMPORTANT: Sprite must be added to stage/container BEFORE calling this function
// dragLayer: Container to move sprite to while dragging (optional, defaults to sprite.parent)
// onDragEnd can return false to snap sprite back to original position
function makeDraggable(sprite, options = {}) {
  sprite.eventMode = 'static';
  sprite.cursor = 'pointer';

  let dragging = false;
  let dragOffset = { x: 0, y: 0 };
  let originalParent = null;
  let originalPosition = { x: 0, y: 0 };
  let dragLayer = options.dragLayer;

  sprite.on('pointerdown', (event) => {
    if (!dragLayer) {
      dragLayer = sprite.parent;
    }

    dragging = true;
    originalParent = sprite.parent;
    originalPosition = { x: sprite.x, y: sprite.y };

    const globalPosition = event.data.global;
    const spriteGlobalPos = sprite.getGlobalPosition();

    dragOffset.x = globalPosition.x - spriteGlobalPos.x;
    dragOffset.y = globalPosition.y - spriteGlobalPos.y;

    if (dragLayer && dragLayer !== sprite.parent) {
      sprite.parent.removeChild(sprite);
      dragLayer.addChild(sprite);
      sprite.x = globalPosition.x - dragOffset.x;
      sprite.y = globalPosition.y - dragOffset.y;
    }

    if (options.onDragStart) {
      options.onDragStart(sprite, event);
    }
  });

  const onMove = (event) => {
    if (!dragging) return;

    const globalPosition = event.data.global;
    sprite.x = globalPosition.x - dragOffset.x;
    sprite.y = globalPosition.y - dragOffset.y;

    if (options.onDrag) {
      options.onDrag(sprite, event);
    }
  };

  const onEnd = (event) => {
    if (!dragging) return;

    dragging = false;

    if (options.onDragEnd) {
      const result = options.onDragEnd(sprite, event, originalParent, originalPosition);

      if (result === false) {
        if (dragLayer && dragLayer !== originalParent) {
          sprite.parent.removeChild(sprite);
          originalParent.addChild(sprite);
          sprite.x = originalPosition.x;
          sprite.y = originalPosition.y;
        } else {
          sprite.x = originalPosition.x;
          sprite.y = originalPosition.y;
        }
      }
    }
  };

  sprite.__dragHandlers = { onMove, onEnd };

  const eventTarget = options.dragGroup || sprite.parent;
  eventTarget.on('pointermove', onMove);
  eventTarget.on('pointerup', onEnd);
  eventTarget.on('pointerupoutside', onEnd);
}

// removeDraggable(sprite) -> void
function removeDraggable(sprite) {
  sprite.eventMode = 'auto';
  sprite.cursor = 'default';
  sprite.removeAllListeners('pointerdown');

  if (sprite.__dragHandlers) {
    const { onMove, onEnd } = sprite.__dragHandlers;
    sprite.parent.off('pointermove', onMove);
    sprite.parent.off('pointerup', onEnd);
    sprite.parent.off('pointerupoutside', onEnd);
    delete sprite.__dragHandlers;
  }
}

// createDropZone(container, {onDrop, highlight}) -> void
// onDrop(draggedSprite, dropZone, dragData) can return false to reject drop
// highlight: {normalColor, hoverColor}
function createDropZone(container, options = {}) {
  container.__isDropZone = true;
  container.__dropZoneOptions = options;

  if (options.highlight) {
    container.eventMode = 'static';

    container.on('pointerover', () => {
      if (options.highlight.hoverColor !== undefined) {
        if (container instanceof PIXI.Graphics) {
          container.tint = options.highlight.hoverColor;
        } else if (container instanceof PIXI.Sprite) {
          container.tint = options.highlight.hoverColor;
        }
      }
    });

    container.on('pointerout', () => {
      if (options.highlight.normalColor !== undefined) {
        if (container instanceof PIXI.Graphics) {
          container.tint = options.highlight.normalColor;
        } else if (container instanceof PIXI.Sprite) {
          container.tint = options.highlight.normalColor;
        }
      }
    });
  }
}

// checkDropZones(draggedSprite, dropZones) -> Container|null
function checkDropZones(draggedSprite, dropZones) {
  const draggedBounds = draggedSprite.getBounds();

  for (const zone of dropZones) {
    const zoneBounds = zone.getBounds();
    if (rectangleCollision(draggedBounds, zoneBounds)) {
      return zone;
    }
  }

  return null;
}

// snapToDropZone(sprite, dropZone, {offsetX, offsetY, animate}) -> void
function snapToDropZone(sprite, dropZone, options = {}) {
  const offsetX = options.offsetX || 0;
  const offsetY = options.offsetY || 0;

  if (sprite.parent !== dropZone) {
    sprite.parent.removeChild(sprite);
    dropZone.addChild(sprite);
  }

  if (options.animate) {
    const targetX = offsetX;
    const targetY = offsetY;

    const animate = () => {
      sprite.x = lerp(sprite.x, targetX, 0.2);
      sprite.y = lerp(sprite.y, targetY, 0.2);

      if (Math.abs(sprite.x - targetX) > 0.1 || Math.abs(sprite.y - targetY) > 0.1) {
        requestAnimationFrame(animate);
      } else {
        sprite.x = targetX;
        sprite.y = targetY;
      }
    };
    animate();
  } else {
    sprite.x = offsetX;
    sprite.y = offsetY;
  }
}

// createDragManager(app, dragLayer) -> DragManager
// Returns: {addDraggable(sprite, {onDragStart, onDrag, onDropSuccess, onDropFail}), addDropZone(container, options), removeDraggable(sprite), removeDropZone(container), clear()}
function createDragManager(app, dragLayer) {
  const manager = {
    draggables: [],
    dropZones: [],
    currentDrag: null,

    addDraggable(sprite, data = {}) {
      sprite.__dragData = data;

      makeDraggable(sprite, {
        dragLayer: dragLayer,
        dragGroup: app.stage,

        onDragStart: (spr, event) => {
          manager.currentDrag = spr;
          if (data.onDragStart) data.onDragStart(spr, event);
        },

        onDrag: (spr, event) => {
          manager.dropZones.forEach(zone => {
            const bounds = spr.getBounds();
            const zoneBounds = zone.getBounds();

            if (rectangleCollision(bounds, zoneBounds)) {
              if (zone.__dropZoneOptions?.highlight?.hoverColor) {
                zone.tint = zone.__dropZoneOptions.highlight.hoverColor;
              }
            } else {
              if (zone.__dropZoneOptions?.highlight?.normalColor !== undefined) {
                zone.tint = zone.__dropZoneOptions.highlight.normalColor;
              }
            }
          });

          if (data.onDrag) data.onDrag(spr, event);
        },

        onDragEnd: (spr, event, originalParent, originalPosition) => {
          const dropZone = checkDropZones(spr, manager.dropZones);

          manager.dropZones.forEach(zone => {
            if (zone.__dropZoneOptions?.highlight?.normalColor !== undefined) {
              zone.tint = zone.__dropZoneOptions.highlight.normalColor;
            }
          });

          if (dropZone) {
            if (dropZone.__dropZoneOptions?.onDrop) {
              const result = dropZone.__dropZoneOptions.onDrop(spr, dropZone, spr.__dragData);

              if (result !== false && data.onDropSuccess) {
                data.onDropSuccess(spr, dropZone);
              }

              manager.currentDrag = null;
              return result;
            }
          }

          if (data.onDropFail) {
            data.onDropFail(spr, originalParent, originalPosition);
          }

          manager.currentDrag = null;
          return false;
        }
      });

      manager.draggables.push(sprite);
    },

    addDropZone(container, options = {}) {
      createDropZone(container, options);
      manager.dropZones.push(container);
    },

    removeDraggable(sprite) {
      removeDraggable(sprite);
      const index = manager.draggables.indexOf(sprite);
      if (index > -1) {
        manager.draggables.splice(index, 1);
      }
    },

    removeDropZone(container) {
      const index = manager.dropZones.indexOf(container);
      if (index > -1) {
        manager.dropZones.splice(index, 1);
      }
    },

    clear() {
      manager.draggables.forEach(sprite => removeDraggable(sprite));
      manager.draggables = [];
      manager.dropZones = [];
      manager.currentDrag = null;
    }
  };

  return manager;
}

// ===== UTILITY FUNCTIONS =====

// randomRange(min, max) -> number
function randomRange(min, max) {
  return Math.random() * (max - min) + min;
}

// randomInt(min, max) -> number
function randomInt(min, max) {
  return Math.floor(randomRange(min, max + 1));
}

// randomChoice(array) -> any
function randomChoice(array) {
  return array[Math.floor(Math.random() * array.length)];
}

// distance(obj1, obj2) -> number
function distance(obj1, obj2) {
  const dx = obj1.x - obj2.x;
  const dy = obj1.y - obj2.y;
  return Math.sqrt(dx * dx + dy * dy);
}

// angleBetween(obj1, obj2) -> number
// Returns angle in radians
function angleBetween(obj1, obj2) {
  return Math.atan2(obj2.y - obj1.y, obj2.x - obj1.x);
}

// moveTowards(object, target, speed) -> void
function moveTowards(object, target, speed) {
  const angle = angleBetween(object, target);
  object.x += Math.cos(angle) * speed;
  object.y += Math.sin(angle) * speed;
}

// clamp(value, min, max) -> number
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

// lerp(start, end, t) -> number
function lerp(start, end, t) {
  return start + (end - start) * t;
}


// ===== ASSET MAP =====
const __ASSET_MAP__ = {
  "player_character": {
    "url": "https://storage.googleapis.com/scraper_ludo/user_images_prod/9269896f6400811439e99c831a9fc913.png",
    "width": 402,
    "height": 715,
    "description": "An elderly woman with long silver hair, wearing a black blouse, black pants, and comfortable walking shoes. She is in a ready stance, facing right, looking determined."
  },
  "boss_pigeon_king": {
    "url": "https://storage.googleapis.com/scraper_ludo/user_images_prod/82162e921ab6c91a78909b3ee3f68377.png",
    "width": 669,
    "height": 601,
    "description": "A very large, aggressive pigeon with dark grey and white feathers, wearing a small golden crown on its head. It has sharp talons and a menacing expression, flying with wings spread, facing right."
  },
  "enemy_pigeon": {
    "url": "https://storage.googleapis.com/scraper_ludo/user_images_prod/f4ddc01bdf3a9cab361bedb38500ceea.png",
    "width": 553,
    "height": 521,
    "description": "A standard pigeon, smaller than the boss, with common grey and iridescent green/purple neck feathers. It looks aggressive, flying with wings spread, facing right."
  },
  "city_park_background": {
    "url": "https://storage.googleapis.com/scraper_ludo/user_images_prod/603e8575aebaf07951b03250dc6c4a74.png",
    "width": 864,
    "height": 640,
    "description": "A detailed, photorealistic 3D rendering of a city park. The background features lush green grass, mature trees with full canopies, park benches, and paved walkways. In the distance, modern city skyscrapers are visible under a clear blue sky."
  },
  "attack_vfx": {
    "url": "https://storage.googleapis.com/scraper_ludo/user_images_prod/034807dab4ba39a10fc4f7cd6d1ea243.png",
    "width": 512,
    "height": 512,
    "description": "A dynamic visual effect representing a swift, impactful combo attack. It consists of glowing white and blue energy streaks with motion lines, suggesting a rapid succession of strikes."
  }
};

// ===== GAME CODE =====
    const app = new PIXI.Application({
  width: 800,
  height: 600,
  backgroundColor: 0x1099bb,
  antialias: true,
  resolution: 1 // ALWAYS force the resolution to 1 to prevent UI placement issues
});
document.body.appendChild(app.view);

    class Game {
    constructor() {
        this.gamePhase = 'dodging';
        this.playerHealth = 100;
        this.bossHealth = 100;
        this.comboMeter = 0;
        this.maxCombo = 5;
        this.attackCount = 0;
        this.maxAttackCount = 10;
        this.projectiles = [];
        this.enemies = [];
        this.attackEffects = [];
        this.playerVelocity = { x: 0, y: 0 };
        this.isDodging = false;
        this.dodgeDirection = 0;
        this.bossPosition = { x: 0, y: 150 };
        this.enemySpawnTimer = 0;
        this.bossAttackTimer = 0;
        this.gameOver = false;
    }
    setup() {
        const background = createSprite('city_park_background');
        background.width = app.screen.width;
        background.height = app.screen.height;
        app.stage.addChildAt(background, 0);
        this.player = createSprite('player_character', {
            x: app.screen.width / 2,
            y: app.screen.height - 150,
            height: 120,
            anchor: 0.5
        });
        app.stage.addChild(this.player);
        this.boss = createSprite('boss_pigeon_king', {
            x: app.screen.width / 2,
            y: 150,
            height: 150,
            anchor: 0.5
        });
        app.stage.addChild(this.boss);
        this.createUI();
        this.createInitialEnemies();
    }
    createUI() {
        const healthBarBg = new PIXI.Graphics();
        healthBarBg.beginFill(0x333333);
        healthBarBg.drawRect(20, 20, 200, 24);
        healthBarBg.endFill();
        app.stage.addChild(healthBarBg);
        this.playerHealthBar = new PIXI.Graphics();
        this.playerHealthBar.beginFill(0x00ff00);
        this.playerHealthBar.drawRect(20, 20, 200, 24);
        this.playerHealthBar.endFill();
        app.stage.addChild(this.playerHealthBar);
        const bossHealthBg = new PIXI.Graphics();
        bossHealthBg.beginFill(0x333333);
        bossHealthBg.drawRect(app.screen.width - 220, 20, 200, 24);
        bossHealthBg.endFill();
        app.stage.addChild(bossHealthBg);
        this.bossHealthBar = new PIXI.Graphics();
        this.bossHealthBar.beginFill(0xff0000);
        this.bossHealthBar.drawRect(app.screen.width - 220, 20, 200, 24);
        this.bossHealthBar.endFill();
        app.stage.addChild(this.bossHealthBar);
        const comboBg = new PIXI.Graphics();
        comboBg.beginFill(0x333333);
        comboBg.drawRect(20, 60, 200, 20);
        comboBg.endFill();
        app.stage.addChild(comboBg);
        this.comboBar = new PIXI.Graphics();
        this.comboBar.beginFill(0xffff00);
        this.comboBar.drawRect(20, 60, 200, 20);
        this.comboBar.endFill();
        app.stage.addChild(this.comboBar);
        this.statusText = createText('DODGE PHASE', {
            fontSize: 24,
            fill: 0xffffff,
            fontWeight: 'bold'
        }, { x: app.screen.width / 2, y: 80, anchor: 0.5 });
        app.stage.addChild(this.statusText);
    }
    createInitialEnemies() {
        for (let i = 0; i < 3; i++) {
            this.spawnEnemy();
        }
    }
    spawnEnemy() {
        const enemy = createSprite('enemy_pigeon', {
            x: randomRange(100, app.screen.width - 100),
            y: randomRange(50, 200),
            height: 60,
            anchor: 0.5
        });
        enemy.velocity = { x: randomRange(-2, 2), y: 1 };
        this.enemies.push(enemy);
        app.stage.addChild(enemy);
    }
    fireProjectile(x, y, targetX, targetY, isBoss = false) {
        const projectile = new PIXI.Graphics();
        projectile.beginFill(isBoss ? 0x8b4513 : 0x4b4b4b);
        projectile.drawCircle(0, 0, isBoss ? 8 : 5);
        projectile.endFill();
        projectile.x = x;
        projectile.y = y;
        const angle = Math.atan2(targetY - y, targetX - x);
        const speed = isBoss ? 8 : 5;
        projectile.velocity = {
            x: Math.cos(angle) * speed,
            y: Math.sin(angle) * speed
        };
        projectile.isBoss = isBoss;
        this.projectiles.push(projectile);
        app.stage.addChild(projectile);
    }
    update(delta) {
        if (this.gameOver) return;
        this.handleInput();
        this.updatePlayer(delta);
        this.updateBoss(delta);
        this.updateEnemies(delta);
        this.updateProjectiles(delta);
        this.updateAttackEffects(delta);
        this.checkCollisions();
        this.updateTimers(delta);
        if (this.gamePhase === 'attack' && isKeyDown(' ')) {
            this.performAttack();
        }
    }
handleInput() {
        if (this.gamePhase === 'dodging') {
            if (isKeyDown('ArrowLeft') && !this.isDodging) {
                this.dodgeLeft();
            } else if (isKeyDown('ArrowRight') && !this.isDodging) {
                this.dodgeRight();
            }
            if (!isKeyDown('ArrowLeft') && !isKeyDown('ArrowRight')) {
                this.isDodging = false;
            }
        }
    }
    dodgeLeft() {
        this.isDodging = true;
        this.dodgeDirection = -1;
        this.playerVelocity.x = -8;
    }
    dodgeRight() {
        this.isDodging = true;
        this.dodgeDirection = 1;
        this.playerVelocity.x = 8;
    }
    updatePlayer(delta) {
        this.player.x += this.playerVelocity.x;
        this.playerVelocity.x *= 0.9;
        this.player.x = Math.max(60, Math.min(app.screen.width - 60, this.player.x));
    }
    updateBoss(delta) {
        const time = Date.now() / 1000;
        this.bossPosition.x = app.screen.width / 2 + Math.sin(time) * 200;
        this.boss.x = this.bossPosition.x;
        this.boss.y = this.bossPosition.y + Math.cos(time * 0.7) * 30;
    }
    updateEnemies(delta) {
        this.enemies.forEach(enemy => {
            enemy.x += enemy.velocity.x;
            enemy.y += Math.sin(Date.now() / 500 + enemy.x) * 0.5;
            if (enemy.x < 50 || enemy.x > app.screen.width - 50) {
                enemy.velocity.x *= -1;
            }
        });
    }
    updateProjectiles(delta) {
        this.projectiles = this.projectiles.filter(projectile => {
            projectile.x += projectile.velocity.x;
            projectile.y += projectile.velocity.y;
            if (projectile.y > app.screen.height || projectile.y < 0) {
                app.stage.removeChild(projectile);
                return false;
            }
            return true;
        });
    }
    updateAttackEffects(delta) {
        this.attackEffects = this.attackEffects.filter(effect => {
            effect.scale.set(effect.scale.x + 0.1);
            effect.alpha -= 0.05;
            if (effect.alpha <= 0) {
                app.stage.removeChild(effect);
                return false;
            }
            return true;
        });
    }
    checkCollisions() {
        this.projectiles.forEach((projectile, index) => {
            if (rectangleCollision(
                { x: projectile.x - 8, y: projectile.y - 8, width: 16, height: 16 },
                { x: this.player.x - 30, y: this.player.y - 60, width: 60, height: 120 }
            )) {
                if (this.gamePhase === 'dodging' && this.isDodging) {
                    this.comboMeter = Math.min(this.comboMeter + 1, this.maxCombo);
                    this.updateComboBar();
                    if (this.comboMeter >= this.maxCombo) {
                        this.switchToAttackPhase();
                    }
                    this.projectiles.splice(index, 1);
                    app.stage.removeChild(projectile);
                } else {
                    this.playerHit();
                    this.projectiles.splice(index, 1);
                    app.stage.removeChild(projectile);
                }
            }
        });
    }
    updateTimers(delta) {
        if (this.gamePhase === 'dodging') {
            this.enemySpawnTimer += delta;
            if (this.enemySpawnTimer > 180) {
                this.enemySpawnTimer = 0;
                if (this.enemies.length < 5) {
                    this.spawnEnemy();
                }
            }
            this.bossAttackTimer += delta;
            if (this.bossAttackTimer > 120) {
                this.bossAttackTimer = 0;
                this.fireProjectile(this.boss.x, this.boss.y, this.player.x, this.player.y, true);
            }
            this.enemies.forEach(enemy => {
                if (randomRange(0, 1) < 0.01) {
                    this.fireProjectile(enemy.x, enemy.y, this.player.x, this.player.y);
                }
            });
        }
    }
    updateComboBar() {
        const percentage = this.comboMeter / this.maxCombo;
        this.comboBar.width = 200 * percentage;
    }
    switchToAttackPhase() {
        this.gamePhase = 'attack';
        this.attackCount = 0;
        this.statusText.text = 'ATTACK PHASE - TAP SPACE!';
        this.comboMeter = 0;
        this.updateComboBar();
        setTimeout(() => {
            this.switchToDodgePhase();
        }, 5000);
    }
    switchToDodgePhase() {
        this.gamePhase = 'dodging';
        this.statusText.text = 'DODGE PHASE';
        this.attackCount = 0;
    }
    performAttack() {
        this.attackCount++;
        const effect = createSprite('attack_vfx', {
            x: this.player.x + randomRange(-50, 50),
            y: this.player.y + randomRange(-30, 30),
            width: 60,
            anchor: 0.5
        });
        effect.alpha = 0.8;
        this.attackEffects.push(effect);
        app.stage.addChild(effect);
        this.bossHealth -= 5;
        this.updateBossHealthBar();
        if (this.bossHealth <= 0) {
            this.victory();
        }
    }
    updateBossHealthBar() {
        const percentage = Math.max(0, this.bossHealth / 100);
        this.bossHealthBar.width = 200 * percentage;
    }
    playerHit() {
        this.playerHealth -= 10;
        const percentage = Math.max(0, this.playerHealth / 100);
        this.playerHealthBar.width = 200 * percentage;
        if (this.playerHealth <= 0) {
            this.gameOver = true;
            showGameOver(app, {
                title: 'GAME OVER',
                score: 0,
                onRestart: () => {
                    this.restart();
                }
            });
        }
    }
    victory() {
        this.gameOver = true;
        showGameOver(app, {
            title: 'VICTORY!',
            score: 1000,
            onRestart: () => {
                this.restart();
            }
        });
    }
    restart() {
        this.gamePhase = 'dodging';
        this.playerHealth = 100;
        this.bossHealth = 100;
        this.comboMeter = 0;
        this.gameOver = false;
        this.updateBossHealthBar();
        this.playerHealthBar.width = 200;
        this.comboBar.width = 0;
        this.statusText.text = 'DODGE PHASE';
        this.projectiles.forEach(p => app.stage.removeChild(p));
        this.projectiles = [];
        this.attackEffects.forEach(e => app.stage.removeChild(e));
        this.attackEffects = [];
    }
}

    
// Preload all assets, then start the game
preloadAssets(__ASSET_MAP__).then(() => {
  let game = new Game(app); // Create the game instance
  game.app = app;
  if (game.setup) game.setup();
  app.ticker.add((delta) => {
    game.update(delta);
  });
});

    </script>
</body>
</html>